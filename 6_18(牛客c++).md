1. fgetc和fputs

> fputs是一个函数，具有的功能是向指定的文件写入一个字符串（不自动写入字符串结束标记符‘\0’）。成功写入一个字符串后，文件的位置指针会自动后移，函数返回值为非负整数；否则返回EOF(符号常量，其值为-1)。
```
int fputs(const char *str, FILE *stream);//成功写入一个字符串返回0，否则返回EOF(-1)
```

> fgetc是一种计算机语言中的函数。意为从文件指针stream指向的文件中读取一个字符，读取一个字节后，光标位置后移一个字节,注意是一个一个字符去读取
```
int fgetc(FILE *stream);
这个函数的返回值，是返回所读取的一个字节。如果读到文件末尾或者读取出错时返回EOF(虽然返回一个字节，但返回值不为unsigned char的原因为，返回值要能表示-1（即为EOF）
```
`标准输入stdin,标准输出stdout，写入文件的话，每次都会刷新文件的内容，即时你之前写入长字符串，后面写入短字符串的话，那么也会刷新为短的字符串`

2. vector中的operator[]和at()函数

> ay() 返回向量中位置n处元素的引用。该函数自动检查n是否在向量中的有效元素的范围内，如果不是（即，如果n大于或等于它的大小）则抛出out_of_range异常。 这与成员运算符[]不同，它不检查边界。
```
reference at (size_type n);
const_reference at (size_type n) const;

```

> operator[],它和成员函数at()的作用是一样的，只是它不变做边界检查！
```
      reference operator[] (size_type n);
const_reference operator[] (size_type n) const;
```

3. 对于逗号表达式来说，一般等于最后面的那个值

```
int a=(1,2,3,4,5);则a=5
```

4. 问题如下

![](https://i.imgur.com/v44Qkte.jpg)

> 解析：首先你要明白的只是1.OXc008只表示一个字节的位置标记，2.小端模式是低位低地址，3.内存对其准则。下面开始分析

> 已知record.a=273转换为16进制就是0x00000111,且record的首地址就是a的起始地址,a为int类型占4个字节，所以0xc008 0xc009 0xc00A 0xc00B 对应的分别是11 01 00 00 ,如果在vs下查看可能一行就显示完了。所以0xc008对应的是11.

> 下面分析record.c的地址，不知道内存对其的可以去我的博客看，a的地址前面 已经阐述为分别为0xc008 0xc009 0xc00A 0xc00B，那么b就紧接着从0xc00C开始分配，占一个字节，此时该分配c但是c是两个字节，前面已经分配了5个字节了，不是2的倍数，所以对其一个字节到0xc00d，所以c从0xc00e开始分配地址.所以record.c的起始地址是0Xc00E.

4. C语言字符串以\0结束，\0在内存中的表示为（）？

> 解析表示为0x00000000，用来标记字符串的结尾，注意和字符0区分。所以其在内存中的形式是0

5. 对于子类继承父类的一些继承和访问权限的问题在这里说明一下。

> public继承：父类中是什么样，子类中就是什么样。
> protected:父类中如果有public，则在子类中变为protecter=d，其他的保持不变
> private:不管父类是什么，在子类中统统改变为peivate

6. 在类型转换中，只能从下往上转，而不能从上往下转，比如0.5默认是double类型的，在就不能将他作为实参传给形参为float的函数。不然会报类型不匹配的错误。

7. 下面代码的输出结果。A.327 B.99  c.328 d.72
```c++
char a=101;
int sum=200;
a+=27;sum+=a;
printf("%d\n",sum);
```
> 输出结果为72.解释一如下，char 默认是有符号的，所以一个字节八位的第八位是符号位,所以其取值范围是-128-127.当a+27=128以后即变成了100000000了，即出现了溢出所以a此时就等于-128了，所以-128在内存中的反码也是10000000，sum是int类型的,所以会将a首先提升为int类型即10000000 0000000 0000000 1000000所以其反码就是11111111 1111111 1111111 1000000，sum的 反码是00000000 00000000 00000000 11001000,二者相加即200-128=72 

8. 引用不能是void类型
9.一下代码的输出结果是什么？
```c++ 
float k=0.8567;
printf("%06.1f%%",k*100);
```
> 6表示输出的字符占6个位置，不包括%，0表示左边不够用0补，1表示小数点保留一位。


