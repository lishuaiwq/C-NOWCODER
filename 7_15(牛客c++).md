1. 如果想使一个数组中全部元素的值为0，可以写成int a[10]={0*10};请问这句话的说法是正确的吗？

> 正确。但是这是一个傻逼出的题！毫无意义。 

2. 若有以下的定义:int t[3][2];能正确表示t数组元素地址的表达式是 t[2]。表述是否正确？。

> 正确。他们的值是相等的但是意义是完全不一样的。t[2]的类型是int[2]*表示的是整个数组的地址，&t[2][0]的类型是int*。

3. C语言中允许函数值类型缺省定义，此时该函数值隐含的类型是int。

> 一、返回值
C中：如果函数未指定返回值类型，则默认为int 
c++中：如果一个函数没有返回值，返回值类型必须指定为void
二、参数列表
C中：如果函数没有指定参数列表，则默认可以接受任意多个参数
C++中：有严格的类型检测，没有参数列表的函数默认为void，不接受任意参数
三、缺省参数（即给参数一个默认值）
C:不支持
C++:支持（如果没有指定实参则使用缺省值，有则使用指定实参）
1.默认实参必须在参数列表的结尾
2.默认参数只能出现在函数声明或者定义二选一中
3.缺省值必须是常量或全局变量
4.缺省参数必须是值传递或者常参传递
四、函数重载
C:不支持
C++:支持在同一作用域中存在几个功能类似的同名函数，但参数列表（参数个数、类型、顺序）不同

4. STL中的哪种结构在增加成员时可能会引起原有成员的存储位置发生改变

> vector,因为其扩容机制是新开辟空间，将原来的内容拷贝过来，红黑树的话只是给变了他的树结构，对于树种的成员的存储位置并没有发生改变。

5. sizeof、和++--是操作符，malloc是函数！
6. 下面函数的调用结果是
```c++
 main()
{ char s[]="123",*p;
p=s;
printf("%c%c%c\n",*p++,*p++,*p++);
}
```

> 输出结果为321，按照c语言的参数里的表达式从右往左计算，因为按照c语言的调用约定，压栈时先压最右边的参数。

7. 下面代码的输出结果是

```
char *c[] = { "ENTER", "NEW", "POINT", "FIRST" }; 
char **cp[] = { c+3, c+2, c+1, c }; 
char ***cpp = cp; 
 
int main(void)
{ 
    printf("%s", **++cpp); 
    printf("%s", *--*++cpp+3); 
    printf("%s", *cpp[-2]+3); 
    printf("%s\n", cpp[-1][-1]+1); 
    return 0;
}
```
> 结果是：POINTERSTEW。解析如下一张图
![](https://i.imgur.com/kMgPplo.jpg)


8. 以下程序运行时输入：123456789↙则程序运行结果是（）？
```
#include <stdio.h>
main()
{
       int  x, y;
       scanf("%2d%*4s%2d",
&x, &y);
       printf("%d",
y-x);
}
```
> 答案是：66.解析如下：%*4s表示读取一个长度为四个字符的字符串，中间的*表示将读取到的字符串忽略，不赋给变量列表中的变量。

9. sizeof(float)是一个整形表达式，因为sizeof()是一个操作符，在编译阶段就获取结果了。这里也提一下strlen，他是函数调用，在运行期间才能获得结果。